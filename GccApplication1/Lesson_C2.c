/*
 * LessonC2.c
 *
 * Created: 18.10.2020 17:33:11
 *  Author: 1
 */ 
 #define F_CPU 1000000
 #include <util/delay.h>
 #include <avr/io.h>
 #include <avr/interrupt.h> //Подключить библиотеку прерываний
 #include "LCD1602wire4.h"
 char i=0,j=0;
 int angle=0;//Угловое положение вала электродвигателя
char k = 0;
int c, c1 = 1000;
int u, u1 = 1000;
 //Инициализация портов
 void Port_ini(void)
 {
	//Инициализация выводов под энкодер
	 DDRD&=~(1<<3)&~(1<<4);
	 PORTD|=(1<<3)|(1<<4);
 }
 //Настройка прерываний
 void interrupt_ini()
 {
	 sei();//Глобальное разрешение прерываний
	 GICR|=(1<<INT1);//разрешить прерывания для входа INT1
	 //Срабатывание внешнего прерывания для входа INT1
	 // по спадающему фронту ISC10=0 ISC11=1
	 MCUCR|=(1<<ISC11);                 
 }
//Функция вывода углового положения на дисплей

 void angle_to_Display(void)
 {
	 char dig1,dig2,dig3;
	 //Разбиение значения углового положения по цифрам
	 dig1 = angle/100;    //Десятки
	 dig2 = angle/10%10;	//Единицы
	 dig3 = angle%10;  //Десятые
	 //Поцифровой вывод углового положения на дисплей
	 setpos_to_LCD(6,0);
	 sendsymbol_to_LCD(dig1+0x30);
	 sendsymbol_to_LCD(dig2+0x30);
	 sendsymbol_to_LCD(dig3+0x30);
 }
 //Функция обработки прерывания по выводу INT1 (PD3)
 ISR(INT1_vect)
 {
		 _delay_us(50);
		 if(~PIND&(1<<4))//Если на выводе PD4 ЛОГ.0
		 {
			 angle=angle+1;        // инкрементировать а
			 if(angle>360)	// если а>345, то a=0;
			 {
				 angle=0;
			 }
			 if (u == u1)
			 {
				 
				 u = angle;
				 u1 = u - 1;
			 }
			 if(u1 == angle)
			 {
				 k += 1;
			 }
			 c = 1000;
			 c1 = 1000;
			 setpos_to_LCD(10,1);
			 string_to_LCD("Right");
			 setpos_to_LCD(14, 0);
			 sendsymbol_to_LCD(k+0x30);
			 		 
		 }
		 else
		 {
			 angle=angle-1;           // декрементировать а
			 if(angle<0)	   // если а<0, то a=345;
			 {
				 angle=360;
			 }
			 if (PIND&(1<<4) && c == c1)
			 {
				 c = angle;
				 c1 = c + 1;
			 }
			 if(c1 == angle)
			 {
				 k += 1;
			 }
			 u = 1000;
			 u1 = 1000;
			 setpos_to_LCD(10,1);
			 string_to_LCD("Left ");
			 setpos_to_LCD(14, 0);
			 sendsymbol_to_LCD(k+0x30);
		 }
		 //Вызов функции вывода углового положения на дисплей
		 angle_to_Display();
 }
//Запись нестандартного символа (градуса) в память дисплея
  void send_gradus(void)
  {
	  //Символ "градус"
	  char gradus[8]={0b01110,
		              0b01010,
		              0b01010,
		              0b01110,
		              0b00000,
		              0b00000,
		              0b00000,
	                  0b00000};//Символ "градус"
	  //Выбор позиции CGRAM: (0x00 - нулевая, 0x08 - первая, 
	  //0x08*2=0x10 - вторая 0x08*3=0x18 - третья и т.д. )
	  sendbyte_to_LCD(0x40|0x08,0); //выбрана первая позиция
	  //Запись массива gradus в первую позицию CGRAM 5x8 пикселей
	  for (unsigned char i = 0; i < 8; i++)sendbyte_to_LCD(gradus[i],1);	  
  }
 //Основная функция
 int main(void)
 {	 
	 interrupt_ini();//Настройка прерываний
	 LCD_ini();//Настройка дисплея
	 Port_ini();//Инициализация портов
	 //Вывод подписей на дисплей
	 setpos_to_LCD(0,0);
	 string_to_LCD("Angle:");
	 setpos_to_LCD(9,0);//Позиция на дисплее, куда записывается символ
	 sendbyte_to_LCD(0x01,1);//Записать первый символ из CGRAM на дисплей
	 send_gradus();//Вывод символа градуса на дисплей
	 setpos_to_LCD(0,1);
	 string_to_LCD("Direction:");
	 setpos_to_LCD(12, 0);
	 string_to_LCD("k:");
	 //Бесконечный цикл
	 while(1)
	 {
	 //Пустой цикл	
	 }
 }
 //ЗАДАЧА: 1)Выводите на дисплей в зависимости от 
 //          направления вращения: <<left или right>>
 //        2)Подсчитывайте число полных оборотов вала
 //          и выводите его на дисплей. 
 //        3)В программе Proteus в настройках мотора-энкодера
 //          измените число импульсов на оборот с 24 до 360.
 //          Измеряйте угловое положение с точностью до 1 градуса
 //Смоделировать в Proteus